# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VcXzMb9P6MQZGm76CPsbATF72GtkVgkE
"""

pip install tensorflow opencv-python matplotlib pandas scikit-learn

from google.colab import drive
drive.mount('/content/drive')

import os
import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, Flatten, Dense, Dropout, Lambda
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
from sklearn.model_selection import train_test_split
from sklearn.utils import shuffle

# Define dataset path
dataset_path = r"/content/drive/MyDrive/dataset"

# Path to labels.txt
labels_file = os.path.join(dataset_path, 'datas.txt')

# Function to load labels from labels.txt
def load_labels(labels_file):
    # Assuming space-separated values: image_filename steering_angle
    df = pd.read_csv(labels_file, sep=' ', header=None, names=['image', 'steering_angle'])
    return df

# Load labels
labels_df = load_labels(labels_file)

# Display the first few entries
print("Labels DataFrame:")
display(labels_df.head())

# Function to load and display images
def display_sample_images(df, folder, num_samples=5):
    plt.figure(figsize=(15, 5))
    for i in range(num_samples):
        img_name = df.iloc[i]['image']
        steering_angle = df.iloc[i]['steering_angle']
        img_path = os.path.join(folder, img_name)
        img = cv2.imread(img_path)
        if img is not None:
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            plt.subplot(1, num_samples, i+1)
            plt.imshow(img)
            plt.title(f"Steering: {steering_angle}°")
            plt.axis('off')
        else:
            print(f"Image {img_path} not found.")
    plt.show()

# Path to images folder
images_folder = os.path.join(dataset_path, 'images')

# Display samples
display_sample_images(labels_df, images_folder, num_samples=5)

# Calculate the number of samples
total_samples = len(labels_df)
print(f"Total samples: {total_samples}")

# Define split ratios
train_ratio = 0.7
val_ratio = 0.15
test_ratio = 0.15

# Calculate split indices
train_end = int(train_ratio * total_samples)
val_end = train_end + int(val_ratio * total_samples)

# Split the DataFrame
train_df = labels_df.iloc[:train_end].reset_index(drop=True)
val_df = labels_df.iloc[train_end:val_end].reset_index(drop=True)
test_df = labels_df.iloc[val_end:].reset_index(drop=True)

print(f"Training samples: {len(train_df)}")
print(f"Validation samples: {len(val_df)}")
print(f"Testing samples: {len(test_df)}")

# Define image dimensions
IMAGE_HEIGHT, IMAGE_WIDTH, IMAGE_CHANNELS = 66, 200, 3  # Inspired by NVIDIA's model

# Define batch size
batch_size = 32

# Function to load and preprocess images
def load_image(img_path):
    img = cv2.imread(img_path)
    if img is None:
        raise FileNotFoundError(f"Image not found: {img_path}")
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = cv2.resize(img, (IMAGE_WIDTH, IMAGE_HEIGHT))
    img = img / 255.0  # Normalize to [0,1]
    return img

# Create a DataFrame with image paths and steering angles
def prepare_dataframe(df, folder):
    df = df.copy()
    df['image_path'] = df['image'].apply(lambda x: os.path.join(folder, x))
    return df[['image_path', 'steering_angle']]

train_df_prepared = prepare_dataframe(train_df, images_folder)
val_df_prepared = prepare_dataframe(val_df, images_folder)
test_df_prepared = prepare_dataframe(test_df, images_folder)

# Display the first few entries
display(train_df_prepared.head())

# Function to load image and label
def load_data(image_path, steering_angle):
    image = tf.io.read_file(image_path)
    image = tf.image.decode_jpeg(image, channels=3)
    image = tf.image.resize(image, [IMAGE_HEIGHT, IMAGE_WIDTH])
    image = tf.cast(image, tf.float32) / 255.0  # Normalize
    steering_angle = tf.cast(steering_angle, tf.float32)
    return image, steering_angle

# Create TensorFlow datasets
def create_tf_dataset(df, batch_size=32, shuffle=False):
    dataset = tf.data.Dataset.from_tensor_slices((df['image_path'].values, df['steering_angle'].values))
    dataset = dataset.map(load_data, num_parallel_calls=tf.data.AUTOTUNE)
    if shuffle:
        dataset = dataset.shuffle(buffer_size=1000)
    dataset = dataset.batch(batch_size)
    dataset = dataset.prefetch(buffer_size=tf.data.AUTOTUNE)
    return dataset

# Create TensorFlow datasets
train_dataset = create_tf_dataset(train_df_prepared, batch_size=batch_size, shuffle=False)
val_dataset = create_tf_dataset(val_df_prepared, batch_size=batch_size, shuffle=False)
test_dataset = create_tf_dataset(test_df_prepared, batch_size=batch_size, shuffle=False)

# Inspect the dataset
for images, angles in train_dataset.take(1):
    print("Image batch shape:", images.shape)
    print("Steering angle batch shape:", angles.shape)

img_shape = (IMAGE_HEIGHT, IMAGE_WIDTH, 3)

base_model = tf.keras.applications.MobileNetV2(input_shape=img_shape,
                                               include_top=False,
                                               weights='imagenet')

base_model.trainable = False

from tensorflow.keras.layers import BatchNormalization

def build_enhanced_cnn_model():
    model = Sequential([
        Lambda(lambda x: x, input_shape=(IMAGE_HEIGHT, IMAGE_WIDTH, IMAGE_CHANNELS)),

        Conv2D(24, (5,5), strides=(2,2), activation='relu', padding='same'),
        BatchNormalization(),

        Conv2D(36, (5,5), strides=(2,2), activation='relu', padding='same'),
        BatchNormalization(),

        Conv2D(48, (5,5), strides=(2,2), activation='relu', padding='same'),
        BatchNormalization(),

        Conv2D(64, (3,3), activation='relu', padding='same'),
        BatchNormalization(),

        Conv2D(64, (3,3), activation='relu', padding='same'),
        BatchNormalization(),

        Flatten(),

        Dense(100, activation='relu'),
        BatchNormalization(),
        Dropout(0.5),

        Dense(50, activation='relu'),
        BatchNormalization(),
        Dropout(0.5),

        Dense(10, activation='relu'),
        BatchNormalization(),

        Dense(1)  # Output layer for steering angle
    ])

    return model

# Instantiate the enhanced model
enhanced_model = build_enhanced_cnn_model()

# Compile the model
enhanced_model.compile(optimizer=Adam(learning_rate=1e-4), loss='mse')

# Display the model summary
enhanced_model.summary()

model.compile(optimizer=Adam(learning_rate=1e-4), loss='mse')

epochs = 5  # Adjust based on when the model converges

history = model.fit(
    train_dataset,
    epochs=epochs,
    validation_data=val_dataset,
    verbose=1
)

plt.figure(figsize=(10,6))
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss Over Epochs')
plt.xlabel('Epoch')
plt.ylabel('Loss (MSE)')
plt.legend()
plt.show()

# Evaluate the model on test data
test_loss = model.evaluate(test_dataset)
print(f"Test MSE Loss: {test_loss}")

# Save the entire model
model.save('model/steering_model_full.h5')



from tensorflow.keras.models import load_model
from tensorflow.keras.losses import mse  # Import the mse loss function

# Load the saved model
loaded_model = load_model('model/steering_model_full.h5', custom_objects={'mse': mse}) # Pass mse to custom_objects

# Predict using the loaded model
sample_image_path = test_df_prepared.iloc[0]['image_path']
sample_angle = test_df_prepared.iloc[0]['steering_angle']
sample_img = load_image(sample_image_path)
sample_img_exp = np.expand_dims(sample_img, axis=0)
predicted_angle = loaded_model.predict(sample_img_exp)[0][0]

print(f"Actual Steering Angle: {sample_angle}°")
print(f"Predicted Steering Angle: {predicted_angle:.2f}°")

from tensorflow.keras.models import load_model
from tensorflow.keras.losses import mse  # Import the mse loss function

# Load the saved model
# Pass mse to custom_objects
model = load_model('model/steering_model_full.h5', custom_objects={'mse': mse})

model

model.summary()

import tensorflow as tf
import scipy.misc
import cv2
from subprocess import call
import skimage
from google.colab.patches import cv2_imshow

sess = tf.compat.v1.InteractiveSession()

img = cv2.imread('/content/drive/MyDrive/dataset/steering_wheel_image.jpg',0)
rows,cols = img.shape

smoothed_angle = 0

cap = cv2.VideoCapture("/content/drive/MyDrive/dataset/2053420-uhd_3840_2160_30fps.mp4")
while(True):
    ret, frame = cap.read()
    image = skimage.transform.resize(frame, [66, 200]) / 255.0
    degrees = model(image.reshape(1, 66, 200, 3)).numpy()[0][0] * 180 / 3.14
    call("clear")
    call("clear")
    print("Predicted steering angle: " + str(degrees) + " degrees")
    cv2_imshow(frame)
    #make smooth angle transitions by turning the steering wheel based on the difference of the current angle
    #and the predicted angle
    smoothed_angle += 0.2 * pow(abs((degrees - smoothed_angle)), 2.0 / 3.0) * (degrees - smoothed_angle) / abs(degrees - smoothed_angle)
    M = cv2.getRotationMatrix2D((cols/2,rows/2),-smoothed_angle,1)
    dst = cv2.warpAffine(img,M,(cols,rows))
    cv2_imshow(dst)

cap.release()
cv2.destroyAllWindows()

